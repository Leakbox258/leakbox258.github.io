---
layout: post
title: "å›¾ç€è‰²å¯„å­˜å™¨åˆ†é…"
date:   2025-5-4
tags: [compiler, æ°´]
comments: true
author: ä¹…èœåˆå­
---

ps: å†™äº›ä¸œè¥¿è¯æ˜è‡ªå·±è¿˜æ´»ç€

## å‰è¨€
##### &emsp;&emsp;&emsp;4æœˆ25æ—¥åå­çš„æ¯”èµ›ç« ç¨‹æŠŠArmèµ›é“çš„ç›®çš„æœºå™¨çš„æ¶æ„æ”¹äº†, ä»ArmV7æ”¹æˆArmV8, ä¹Ÿå³ä»è¦æ±‚ç¼–è¯‘A32æ¨¡å¼æ›´æ”¹ä¸ºè¦æ±‚ç¼–è¯‘A64æ¨¡å¼ä»£ç <br>
##### &emsp;&emsp;&emsp;å®é™…ä¸Šè¿™ä¸ªè¡Œä¸ºå¾ˆéš¾è¯„ä»·, ä»2020å¹´æœ‰è¿™ä¸ªæ¯”èµ›å¼€å§‹Armèµ›é“çš„ç« ç¨‹å°±å‡ ä¹ä»æ²¡å˜è¿‡, å¯¼è‡´å½“å¹´çœ‹èµ·æ¥æ¯”è¾ƒæ–°çš„å·¥å…·é“¾(å¦‚gcc 7.9.0çš„é“¾æ¥å™¨)å·²ç»è¿œè¿œè¿‡æ—¶äº†, æ—§çš„å·¥å…·é“¾å¯ä»¥å…è®¸ä½ç½®æœ‰å…³ä»£ç ä½¿ç”¨, å³`-fno-PIC`<br>
##### &emsp;&emsp;&emsp; A32çš„æ€§èƒ½ä¼˜åŒ–å®é™…ä¸Šä¹Ÿæœ‰ç“¶é¢ˆ, ä¾‹å¦‚ArmV7èƒ½å¤Ÿè¿›è¡ŒSIMDè¿ç®—, ä½†å—åˆ¶äºæµ®ç‚¹åå¤„ç†å™¨çš„å¯„å­˜å™¨çš„ä½¿ç”¨è§„åˆ™ä»¥åŠA32ä¸å¤Ÿç”¨çš„å¯„å­˜å™¨æ•°é‡, å¯¼è‡´å®ç°SIMDçš„éš¾åº¦è¾ƒå¤§, æ‰€ä»¥ä¸€ç›´æ²¡äººåš, é€šç”¨å¯„å­˜å™¨çš„æ•°é‡ä¸€æ ·æ‰è¥Ÿè§è‚˜, å³ä½¿æ˜¯ç¼–ç ç›¸å¯¹åˆç†çš„performanceæµ‹ä¾‹ä¹Ÿå­˜åœ¨è¾ƒå¤šçš„spill<br>
###### &emsp;&emsp;&emsp;è¿˜æœ‰å°±æ˜¯è¿™ä¸ªæ¿å­çš„é—®é¢˜(èµ›çµæ€çš„é‚£ä¸ªæ¿å­), Cortex-A53æ˜¯ArmV8æ—©æœŸçš„ä¸€ä¸ªèŠ¯ç‰‡, ä»¥è‡³äºè¿™ä¸ªèŠ¯ç‰‡ç°åœ¨æ·˜å®å’¸é±¼ä¸Šå‡ ä¹ç»è¿¹, å¤–ç½‘ä¸Šä¸Šåƒä¸€å—. è¿™ä¸ªæ¿å­ä¸è‡³äºè®©æ¯”èµ›çš„éš¾åº¦ä¸Šå‡å¤ªå¿«, ä¹Ÿæ¯”è¾ƒé€‚åˆåšSIMD, æ¯•ç«Ÿéƒ½æŠŠSIMDå†™åˆ°ç« ç¨‹ä¸Šäº†, è¿˜é™åˆ¶äº†å¤šçº¿ç¨‹, è¯´æ˜ä»Šå¹´çš„çƒ­ç‚¹å°±æ˜¯åšå‘é‡åŒ–çš„ä¼˜åŒ–, æ¯•ç«Ÿå†ä¸åšå‡ºæ”¹å˜, å¹½å·é£å¤©å¤§å­¦å°±è¦åœ¨è¿™æ–¹é¢ä¸€å®¶ç‹¬å¤§äº†

## å¯„å­˜å™¨ç»„å’Œè°ƒç”¨è§„çº¦
##### &emsp;&emsp;&emsp;å¯„å­˜å™¨åˆ†é…é¦–å…ˆéœ€è¦äº†è§£å¯„å­˜å™¨ç»„
|æ¶æ„|é€šç”¨å¯„å­˜å™¨|å•ç²¾åº¦æµ®ç‚¹|åŒç²¾åº¦æµ®ç‚¹|4å­—å‘é‡å¯„å­˜å™¨|
|:---:|:---:|:---:|:---:|:---:|
|A32|r0-r15|s0-s31|d0-d31|q0-q16|
|A64|X0-X30, SP, PC|s0-s31|d0-d31|q0-q31|
##### &emsp;&emsp;&emsp;çœ‹èµ·æ¥ç±»ä¼¼, å®é™…ä¸Šå®Œå…¨ä¸ä¸€æ ·<br>
#### &emsp;A32æ¨¡å¼
##### &emsp;&emsp;&emsp;A32ä¸‹, caller-saveä¸º`r0-r3 + r12(ip) + s0-s15`, æŠŠè¿‡ç¨‹é—´å¯„å­˜å™¨`ip`ä¹Ÿç®—ä½œcaller-save, æ–¹ä¾¿ç®€åŒ–è§„çº¦, å‰©ä¸‹çš„æ˜¯callee-save(å¦‚æœä¼ å‚åªæœ‰int32å’Œå•ç²¾åº¦æµ®ç‚¹æ•°)<br>&emsp;&emsp;&emsp;å…³äºæµ®ç‚¹å¯„å­˜å™¨, è¿™é‡Œéœ€è¦ä¸Šä¸€å¼ é™ˆå¹´è€å›¾
![alt text](../images/registeralloc/1.png)
##### &emsp;&emsp;&emsp;ä»¥Neonä¸ºä¾‹(å®é™…ä¸Šå’Œå›¾ä¸Šæœ‰å‡ºå…¥, ä¹¦å†™æ±‡ç¼–æ—¶å¯ä»¥ç”¨`s<>`å¯„å­˜å™¨), ç›¸é‚»å¹¶ä¸”å¯¹é½çš„ä¸¤ä¸ª`s<>`å¯„å­˜å™¨æ˜¯ä¸€ä¸ª`d<>`çš„ä¸åŒè§†å›¾, ç›¸é‚»å¹¶ä¸”å¯¹é½çš„ä¸¤ä¸ª`d<>`æ˜¯`q<>`çš„è§†å›¾, è¿™ç§ç©ºé—´å æœ‰æ–¹å¼æé«˜äº†åˆ©ç”¨ç‡, ä½†æ˜¯ä¸åˆ©äºSIMD, ä¸€æ–¹é¢æ˜¯å¯„å­˜å™¨æœ¬èº«ä¸å¤Ÿ, éœ€è¦åŒæ—¶ç»™å•ç²¾åº¦, åŒç²¾åº¦å’Œ4å­—å‘é‡ä½¿ç”¨, å¹¶ä¸”åŒç²¾åº¦å’Œå‘é‡æœ‰å¯¹é½éœ€æ±‚, å¯„å­˜å™¨åˆ†é…æ—¶å¾ˆéš¾ä¿è¯åŒä¸€æ—¶é—´ç©ºé—´ä¸­, åˆ†é…å‡ºå¯„å­˜å™¨å°½é‡çš„å¯¹é½(å³å°šæœ‰ç©ºé—´æ—¶ä¸è·¨è¶Š`Q<>`è¾¹ç•Œåˆ†é…)<br>
#### &emsp;A64æ¨¡å¼
##### &emsp;&emsp;&emsp;A64ä¸‹, caller-saveä¸º`X0-X15 + X16 + X17 + V0-V15`<br>&emsp;&emsp;&emsp;A64ä¸‹çš„å¯„å­˜å™¨è§†å›¾ç®€å•çš„å¤š, `w<>`å³å¯¹åº”çš„`X<>`çš„ä½32ä½, å¹¶ä¸”ä½¿ç”¨æ—¶é«˜ä½æ¸…é›¶; `s<>`, `d<>`æ˜¯`V<>`çš„ä½32ä½å’Œä½64ä½, `q<>`æ˜¯å¯¹åº”`V<>`çš„åˆ«å<br>
##### &emsp;&emsp;&emsp;`V<>`å’Œ`q<>`æ˜¯åŒæ ·çš„ç©ºé—´, ä½†æ˜¯ä¸åŒçš„ç”¨é€”, äº‹å®ä¸Š, æ ¹æ®ä¸ªäººçš„è§‚å¯Ÿ, `q<>`çš„è®¿é—®å†…å­˜å’Œå†™å…¥å†…å­˜æ›´æ–¹ä¾¿, èƒ½å¤Ÿä½¿ç”¨`åŸºå€ + åç§»`çš„å¯»å€æ–¹å¼, è€Œ`V<>`èƒ½å¤Ÿç²¾ç»†åœ°æŒ‡ç¤ºéœ€è¦æ‰§è¡Œçš„å‘é‡æ“ä½œ

## å›¾ç€è‰²ç®—æ³•(æ³¨æ„äº‹é¡¹)
##### &emsp;&emsp;&emsp;è¿™é‡Œä½¿ç”¨çš„æ˜¯`Iterated Register Coalescing`çš„å¯„å­˜å™¨åˆ†é…ç®—æ³•, é€‰ä»–æ˜¯å› ä¸ºå†…ç½®äº†`Register Coalescing`, è¿™æ ·å°±ä¸ç”¨è‡ªå·±åœ¨åšä¸€æ¬¡å¯„å­˜å™¨åˆå¹¶, é™¤æ­¤ä¹‹å¤–, `Register Coalescing`å¯¹äº`phiEli`äº§ç”Ÿçš„å†—ä½™copyæŒ‡ä»¤ä¹Ÿæœ‰ä¸é”™çš„æ¶ˆé™¤æ•ˆæœ
![alt text](../images/registeralloc/2.png)
#####  &emsp;&emsp;&emsp;è¿™ä¸ªç®—æ³•çš„åŸç†, è¯´å®è¯æ²¡ä»€ä¹ˆå¥½çœ‹çš„, ä¸¤ä¸ªèµ›é“ç°åœ¨éƒ½æ˜¯64ä½éƒ½ä¸ç¼ºå¯„å­˜å™¨ç”¨çš„æƒ…å†µä¸‹, å›¾ç€è‰²è§£å†³å†²çªçš„æ•ˆæœå¹¶ä¸æ¯”çº¿æ€§æ‰«ææ˜æ˜¾ç‰¹åˆ«å¤š(æ‰€ä»¥æœ‰äº›ä¹°æ¤Ÿè¿˜ç çš„æ„æ€), æ–‡ç« æœ«å°¾çš„ä¼ªä»£ç å®é™…ä¸Šæ›´æœ‰ä»·å€¼<br>
#### &emsp;ç¨‹åºå…¥å£å’Œå‡†å¤‡å·¥ä½œ
##### &emsp;&emsp;&emsp;`procedure`è°ƒç”¨`function`, å…¶ä¸­`Main`è¿™ä¸ª`procedure`ä¸ºæ•´ä¸ªç¨‹åºçš„å…¥å£, é€’å½’æ‰§è¡Œ, ä¸è¿‡ä¹Ÿå¯ä»¥æ”¹æˆå¾ªç¯<br>
##### &emsp;&emsp;&emsp;åœ¨è¿›è¡Œ`Main`ä¹‹å‰, éœ€è¦å…ˆå‡†å¤‡ä¸‰æ ·ä¸œè¥¿:
&emsp;&emsp;&emsp;- `initial`å¾…ç€è‰²çš„ç»“ç‚¹, å°±æ˜¯operands
&emsp;&emsp;&emsp;-`precolors`é¢„ç€è‰²çš„æ“ä½œæ•°, æ¯”å¦‚ç”¨äºä¼ å‚çš„å¯„å­˜å™¨
&emsp;&emsp;&emsp;-`liveinfo`æ´»è·ƒä¿¡æ¯, å…¶å®åªéœ€è¦æ¯ä¸ªblkçš„liveinå’Œliveout, ä¸å¿…ç²¾ç»†åˆ°æ¯ä¸ªinstructionçš„livein, liveout
#### &emsp;éœ€è¦Coaleseçš„Moveçš„å®šä¹‰
##### &emsp;&emsp;&emsp;å…³äº`move`çš„å®šä¹‰, å¯ä»¥æ˜¯MIRä¸­è®¾è®¡çš„ç±»ä¼¼æ±‡ç¼–ä½œç”¨çš„`mov`(å¹¶ä¸”`src`å’Œ`dst`å‡ä¸ºå¯„å­˜å™¨), ç”¨äºlegalize; æˆ–è€…æ˜¯æ’å…¥çš„copyè¯­å¥, å¦‚å°†ISAå¯„å­˜å™¨(ä½œä¸ºå‚æ•°æˆ–è€…è¿”å›å€¼)æ‹·è´åˆ°VRegå¯„å­˜å™¨ä»¥ä¿è¯è¯­ä¹‰æ­£ç¡®; å½“ç„¶è¿˜æœ‰Phiæ¶ˆé™¤çš„äº§ç”Ÿçš„copy
#####  &emsp;&emsp;&emsp;ä¸¾ä¾‹å¦‚ä¸‹LLVM IR
```
define dso_local i32 @func(i32 noundef %0, i32 noundef %1){
    ...
}

define dso_local i32 @main(){
    ...
    %114514 = call i32 @func(i32 noundef %114, i32 noundef %514)
    ...
}
```
##### &emsp;&emsp;&emsp;ä¸ºäº†ç¡®ä¿ä¼ å‚å’Œè¿”å›çš„æ­£ç¡®æ€§, éå¸¸å»ºè®®è®¾è®¡`copy`è¯­å¥, å¹¶ä¸”è¿›è¡Œå¦‚ä¸‹å¤„ç†
```
func:
    %0 = copy $w0
    %1 = copy $w1
    ...

main:
    ...
    $w0 = copy %114
    $w1 = copy %514
    bl func
    %114514 = copy $w0
    ...
```
##### &emsp;&emsp;&emsp;å¦‚æœæ„¿æ„æˆ–è€…æœ‰éœ€æ±‚, å¯ä»¥æ ¹æ® `sre op` å’Œ `dst op` æ˜¯VRegæˆ–è€…æ˜¯ISARegè¿›è¡Œåˆ†ç±», ä¹Ÿå°±æ˜¯å…±å››ç§æ›´ç»†åˆ†çš„copy

##### &emsp;&emsp;&emsp;æ³¨æ„è®ºæ–‡ä¸­çš„ä¸€ä¸ªç¬”è¯¯, åœ¨` procedure Combine(u,v)`çš„ç¬¬ä¸ƒè¡Œ, å‡ºç°äº†`nodeMoves`, ä½†è¿™ä¸ªå˜é‡æ ¹æœ¬æ²¡æœ‰è¢«å£°æ˜, ç»è¿‡æœ¬äººå®éªŒä»¥åŠå‚è€ƒå¾€å¹´å‚èµ›é˜Ÿçš„å›¾ç€è‰²ç®—æ³•, `nodeMoves`åº”è¯¥æ˜¯`moveList`, å³ä¸ä¸€ä¸ªoperandç›¸å…³çš„moveè¯­å¥çš„é›†åˆ

#### &emsp;å¯å‘å¼ç®—æ³•
##### &emsp;&emsp;&emsp;ç”±äºå›¾ç€è‰²æœ¬èº«æ˜¯ä¸€ä¸ªNPä¸å®Œå…¨é—®é¢˜, æ‰€ä»¥åœ¨è®ºæ–‡çš„åŸºç¡€ä¸Š, æœ‰å‡ å¤„éœ€è¦è¿›è¡Œå¯å‘å¼ç®—æ³•
&emsp;&emsp;&emsp;-`Simplify`, `Coalesce`, `Freeze`ä¸‰å¤„`procedure`çš„é¦–éƒ¨, ä»é›†åˆ(Operandé›†æˆ–è€…Instructioné›†)è·å–ä¸€ä¸ªå…ƒç´ è¿›è¡Œå¤„ç†, æ ¹æ®åœ¨A32çš„æµ‹è¯•, è®¾ç½®åˆç†çš„å¯å‘å¼å…ƒç´ è·å–ç®—æ³•ç¡®å®å¯ä»¥å‡å°‘spill, ä½†æ˜¯æ•ˆæœä¸å¾ˆæ˜æ˜¾
&emsp;&emsp;&emsp;-`SelectSpill`ç¬¬äºŒå¤„å¯å‘å¼, è¿™é‡Œçš„æœ€ä½è¦æ±‚æ˜¯ä¸è¦å°†ä¹‹å‰æº¢å‡ºå¾—åˆ°çš„ç”¨äºstageçš„è™šæ‹Ÿå¯„å­˜å™¨å†æ¬¡æº¢å‡º, å¦åˆ™æ²¡å®Œæ²¡äº†; åœ¨æ­¤ä¹‹ä¸Š, å¯ä»¥è®¾ç½®å¯¹äºå¯„å­˜å™¨æº¢å‡ºçš„åå¥½, æ¯”å¦‚è®¡ç®—Operandsçš„liveIntervalLength, å°½é‡ä¸æº¢å‡ºåŸºåœ°å€æˆ–è€…å¾ªç¯ä¸å˜é‡; ä¸è¿‡æ ¹æ®ç»éªŒ, è¿™é‡Œä»€ä¹ˆéƒ½ä¸å¹²ä¹Ÿèƒ½è¿‡
```
procedure SelectSpill()
    let m âˆˆ spillWorklist selected using favorite heuristic
    Note: avoid choosing nodes that are the tiny live ranges
    resulting from the fetches of previously spilled registers

    spillWorklist := spillWorklist \{m}
    simplifyWorklist := simplifyWorklist âˆª{m}
    FreezeMoves(m)
``` 
#### &emsp;å¦‚ä½•å¤„ç†Multiple Register Bank
##### &emsp;&emsp;&emsp;ä¸åŒçš„Register Bankçš„åˆ†é…å¯ä»¥åˆ†æ‰¹è¿›è¡Œ. å¦‚æœæ˜¯A32åç«¯, éœ€è¦è¿›è¡Œ`Spill to spr`çš„ä¼˜åŒ–, é‚£ä¹ˆ`spr`åœ¨`gpr`ä¹‹å‰åˆ†é…. é™¤æ­¤ä¹‹å¤–åšå¥½éš”ç¦»å³å¯.
#### &emsp;è°ƒç”¨è§„çº¦å¤„ç†
##### &emsp;&emsp;&emsp;ä¹Ÿå°±æ˜¯å¤„ç†`callee-save`å’Œ`caller-save`çš„æ–¹æ³•
&emsp;&emsp;&emsp;-`callee-save`: ä¸¤ç§æ–¹æ¡ˆ
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1. è™ä¹¦æ–¹æ¡ˆ: åœ¨å‡½æ•°çš„å¼€å¤´å’Œç»“å°¾æ’å…¥movæˆ–è€…copyè¯­å¥, å®ç°è¯­ä¹‰ä¸Šçš„stage; å¦‚æœè¯¥stageå¤šä½™, ä¼šè¢«`register coalesce`åˆå¹¶, å¦‚æœå¯„å­˜å™¨å‹åŠ›å¤§, ä¼šè¢«spill
```
foo:
    %stage_1 = copy $r4
    %stage_2 = copy $r5
    %stage_3 = copy $r6
    ...
    ...
    $r4 = copy %stage_1
    $r5 = copy %stage_2
    $r6 = copy %stage_3

    ; ä½ çŒœä¸ºä»€ä¹ˆç”¨A32ç¤ºä¾‹
```
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2. ç™½ç—´æ–¹æ¡ˆ(æˆ‘çš„æ–¹æ¡ˆ): ç€è‰²æ—¶ç›´æ¥è®°å½•å¯„å­˜å™¨åˆ†é…æƒ…å†µ, ç„¶ååœ¨Prologueå’ŒEpilogueåœ¨æ ˆä¸Šä¿å­˜å’Œæ¢å¤

## ä»£ç (ç‚¹è¿›æ¥å°±æ˜¯æ¥æ‰¾è¿™ä¸ªçš„?ğŸ¤£)
##### &emsp;&emsp;&emsp;ä»£ç åŒ…è£…ä¸ºä¸€ä¸ªImplementçš„Class, ç»„ç»‡é€»è¾‘æ˜¯`procedure + function + tools`, `tools`çš„éƒ¨åˆ†éœ€è¦æ ¹æ®MIRçš„ç»“æ„è‡ªè¡Œå®Œæˆ, `MIROperand_p`, `MIRFunction`ç­‰éœ€è¦æ›´æ¢

```c++

class RegisterAllocImpl {
public:
    using OperSet = std::set<MIROperand_p>;
    using WorkList = std::set<MIROperand_p>;
    using Nodes = std::set<MIROperand_p>;
    using Moves = std::set<MIRInst_p>;

    struct Edge {
        MIROperand_p u, v;
        bool operator==(const Edge &anthor) const;
    };

    struct EdgeHash {
        std::size_t operator()(const Edge &_edge) const {
            return std::hash<std::size_t>()(static_cast<std::size_t>(reinterpret_cast<uintptr_t>(_edge.v.get())) ^
                                            static_cast<std::size_t>(reinterpret_cast<uintptr_t>(_edge.u.get())));
        }
    };

public:
    virtual void impl(MIRFunction &, FAM &);
    RegisterAllocImpl() = default;
    virtual ~RegisterAllocImpl() = default;

protected:
    MIRFunction *mfunc;

    OperSet precolored;
    OperSet initial;

    WorkList simplifyWorkList;
    WorkList freezeWorkList;
    WorkList spillWorkList;

    Nodes coalescedNodes;
    Nodes spilledNodes;
    Nodes coloredNodes;

    // Operands wait to be colored
    std::vector<MIROperand_p> selectStack;

    Moves coalescedMoves;
    Moves constrainedMoves;
    Moves frozenMoves;
    Moves worklistMoves;
    Moves activeMoves;

    // others
    std::unordered_set<Edge, EdgeHash> adjSet;
    std::map<MIROperand_p, OperSet> adjList;
    std::map<MIROperand_p, unsigned int> degree; // precolored will be initialize with -1
    std::map<MIROperand_p, Moves> moveList;
    std::map<MIROperand_p, MIROperand_p> alias;
    // color
    unsigned int K = Config::MIR_new::CORE_REGISTER_MAX_NUM;

protected:
    /// procedures
    void Main(FAM &);
    void Build();
    void MkWorkList();
    void AddEdge(const MIROperand_p &, const MIROperand_p &);
    void Simplify();
    void DecrementDegree(const MIROperand_p &);
    void EnableMoves(const Nodes &);
    void Coalesce();
    void AddWorkList(const MIROperand_p &);
    void Combine(const MIROperand_p &, const MIROperand_p &);
    void Freeze();
    void FreezeMoves(const MIROperand_p &);
    void SelectSpill();
    virtual void AssignColors();

    void ReWriteProgram();

protected:
    /// function
    Nodes Adjacent(const MIROperand_p &);
    Moves NodeMoves(const MIROperand_p &);
    bool MoveRelated(const MIROperand_p &);

    bool OK(const MIROperand_p &t, const MIROperand_p &r); // åˆå¹¶precoloredçš„å¯å‘å¼ç®—æ³•
    bool Conservative(const Nodes &);                      // Briggs å¼€å‘çš„åˆå¹¶å¯å‘å¼ç®—æ³•
    MIROperand_p GetAlias(MIROperand_p);                   

protected:
    /// tools
    void clearall();

    std::set<int> colors;

    bool isInitialed;

    Liveness liveinfo;

    virtual bool isMoveInstruction(const MIRInst_p &);

    virtual Nodes getUse(const MIRInst_p &);
    virtual Nodes getDef(const MIRInst_p &);

    template <typename Cx, typename Cy> void addBySet(Cx &victim, const Cy &set) {
        static_assert(std::is_same_v<typename Cx::value_type, typename Cy::value_type>,
                      "Cx Cy element types must be identical");

        for (const auto &ptr : set) {
            victim.insert(ptr);
        }
    }
    template <typename Cx, typename Cy> void delBySet(Cx &victim, const Cy &set) {
        static_assert(std::is_same_v<typename Cx::value_type, typename Cy::value_type>,
                      "Cx Cy element types must be identical");

        for (const auto &ptr : set) {
            victim.erase(ptr);
        }
    }

    template <typename T, typename... Tsets> std::set<T> getUnion(Tsets... sets) {
        std::set<T> union_set;
        (union_set.insert(sets.begin(), sets.end()), ...);
        return union_set;
    }

    template <typename T, typename... Tsets> std::set<T> getExclude(std::set<T> victim, Tsets... sets) {
        auto exclude_set = std::move(victim);

        auto lambda = [&exclude_set](const auto &set) -> void {
            for (const auto &t : set) {
                exclude_set.erase(t);
            }
        };

        (lambda(sets), ...);
        return exclude_set;
    }

    MIROperand_p heuristicSpill();

    virtual Nodes spill(const MIROperand_p &);

    unsigned int spilltimes = 0;
};
```
##### &emsp;&emsp;&emsp;å¯¹äºä¸åŒçš„Register Bank, ç›´æ¥ç»§æ‰¿è¯¥Classå¹¶é‡å†™å‡ ä¸ªè™šå‡½æ•°å³å¯<br>
##### &emsp;&emsp;&emsp;æœ‰å‡ ä¸ªå·¥ç¨‹ç»†èŠ‚éœ€è¦æ³¨æ„:
&emsp;&emsp;&emsp;- 1. ä¸ºäº†ä¿è¯ç¼–è¯‘ç»“æœå”¯ä¸€, ç¬¬ä¸€: ä¸è¦å¼•å…¥éšæœºç®—æ³•; ç¬¬äºŒ: è¦éå†çš„å®¹å™¨åˆ«æ˜¯hashå®ç°
&emsp;&emsp;&emsp;- 2. `initial`é›†, æˆ‘é€‰æ‹©åœ¨é¦–æ¬¡è¿›å…¥`Build()`æ—¶, éå†Instrctionsè·å–, å¯ä»¥è¢«æ”¾åœ¨åˆ«çš„åœ°æ–¹
&emsp;&emsp;&emsp;- 3. å®¹å™¨è®°å¾—Clear
&emsp;&emsp;&emsp;- 4. ç¤ºä¾‹å¯„å­˜å™¨ä½¿ç”¨çš„æ˜¯A64 CoreRegister
&emsp;&emsp;&emsp;- 5. toolså’Œ`AssignColor`è‡ªå·±å»å®ç°
&emsp;&emsp;&emsp;- 6. `impl`æ˜¯Classçš„å®é™…å…¥å£
&emsp;&emsp;&emsp;- 7. ç”±äºæœ¬äººå¾ˆèœ, æ‰€ä»¥è¿™ä¸ªå®ç°å¹¶éæ˜¯è¿è¡Œæ€§èƒ½æœ€ä½³çš„, è¯¥ä»£ç å­˜åœ¨çš„æ„ä¹‰å°±æ˜¯ä¸ç”¨å¯¹ç…§è®ºæ–‡ä¸€å¥ä¸€å¥ç¿»è¯‘

```c++
void RegisterAllocImpl::Main(FAM &fam) {
    
    Build();
    MkWorkList();

    while (!simplifyWorkList.empty() || !worklistMoves.empty() || !freezeWorkList.empty() || !spillWorkList.empty()) {
        if (!simplifyWorkList.empty()) {
            Simplify();
        } else if (!worklistMoves.empty()) {
            Coalesce();
        } else if (!freezeWorkList.empty()) {
            Freeze();
        } else if (!spillWorkList.empty()) {
            SelectSpill();
        }
    }

    AssignColors();

    if (!spilledNodes.empty()) {
        ReWriteProgram();

        Main(fam);
    }
}

void RegisterAllocImpl::AddEdge(const MIROperand_p &u, const MIROperand_p &v) {
    Edge edge{u, v};

    if (u != v && adjSet.find(edge) == adjSet.end()) {
        adjSet.insert(std::move(edge));

        if (precolored.find(u) == precolored.end()) {
            adjList[u].insert(v);
            ++degree[u];
        }

        if (precolored.find(v) == precolored.end()) {
            adjList[v].insert(u);
            ++degree[v];
        }
    }
}

void RegisterAllocImpl::Build() {
    ///@note MkInitial
    if (!isInitialed) {

        for (const auto &blk : mfunc->blks()) {
            for (const auto &inst : blk->Insts()) {

                const auto &use = getUse(inst);
                const auto &def = getDef(inst);

                for (const auto &n : getUnion<MIROperand_p>(def, use)) {
                    if (n->isISA()) {
                        precolored.insert(n);
                        degree[n] = -1; // degree of precolored assign as very large
                    } else if (n->isVReg()) {
                        initial.insert(n);
                    }
                }
            }
        }
    }
    isInitialed = true;

    for (const auto &blk : mfunc->blks()) {

        auto live = liveinfo.liveOut[blk];
        const auto &insts = blk->Insts();

        for (auto inst_it = insts.rbegin(); inst_it != insts.rend(); ++inst_it) {
            const auto &inst = *inst_it;

            const auto &use = getUse(inst);
            const auto &def = getDef(inst);

            if (isMoveInstruction(inst)) {
                delBySet(live, use);

                for (const auto &n : getUnion<MIROperand_p>(def, use)) {
                    addBySet(moveList[n], Moves{inst});
                }

                addBySet(worklistMoves, Moves{inst});
            }

            addBySet(live, def);

            for (const auto &d : def) {
                for (const auto &l : live) {
                    AddEdge(l, d);
                }
            }

            delBySet(live, def);
            addBySet(live, use);
        }
    }
}

void RegisterAllocImpl::MkWorkList() {
    for (auto it = initial.begin(); it != initial.end();) {
        const auto n = *it;

        if (degree[n] >= K) {
            addBySet(spillWorkList, WorkList{n});
        } else if (MoveRelated(n)) {
            addBySet(freezeWorkList, WorkList{n});
        } else {
            addBySet(simplifyWorkList, WorkList{n});
        }

        it = std::next(it);
        delBySet(initial, WorkList{n});
    }
}

void RegisterAllocImpl::Simplify() {

    auto it = simplifyWorkList.begin();

    const auto n = *it;

    simplifyWorkList.erase(it);

    selectStack.emplace_back(n);

    for (const auto &m : Adjacent(n)) {
        DecrementDegree(m);
    }
}

void RegisterAllocImpl::DecrementDegree(const MIROperand_p &m) {
    auto d = degree[m];

    --degree[m];

    if (d == K) {
        EnableMoves(getUnion<MIROperand_p>(Nodes{m}, Adjacent(m)));
        delBySet(spillWorkList, WorkList{m});

        if (MoveRelated(m)) {
            addBySet(freezeWorkList, WorkList{m});
        } else {
            addBySet(simplifyWorkList, WorkList{m});
        }
    }
}

void RegisterAllocImpl::EnableMoves(const Nodes &nodes) {
    for (const auto &n : nodes) {
        for (const auto &m : NodeMoves(n)) {
            if (activeMoves.find(m) != activeMoves.end()) {
                delBySet(activeMoves, Moves{m});
                addBySet(worklistMoves, Moves{m});
            }
        }
    }
}

void RegisterAllocImpl::Coalesce() {

    auto it = worklistMoves.begin();

    auto m = *it;
    worklistMoves.erase(m);

    auto x = *(getDef(m).begin());
    auto y = *(getUse(m).begin());

    auto x_a = GetAlias(x);
    auto y_a = GetAlias(y);

    Edge edge{nullptr, nullptr};
    if (precolored.find(y_a) != precolored.end()) {
        edge.u = y_a, edge.v = x_a;
    } else {
        edge.u = x_a, edge.v = y_a;
    }

    auto &u = edge.u;
    auto &v = edge.v;
    if (u == v) {
        addBySet(coalescedMoves, Moves{m});
        AddWorkList(u);
    } else if (precolored.find(v) != precolored.end() || adjSet.find(edge) != adjSet.end()) {
        addBySet(constrainedMoves, Moves{m});
        AddWorkList(u);
        AddWorkList(v);
    }
    ///@note å°†è®ºæ–‡çš„ä¸€ä¸ªif-elseæ‹†æˆäº†ä¸¤ä¸ª
    else if (precolored.find(u) != precolored.end()) {
        ///@note George check

        bool flag = true;
        for (const auto &t : Adjacent(v)) {
            if (!OK(t, u)) {
                flag = false;
                break;
            }
        }

        if (flag) {
            goto __Combine_try;
        } else {
            goto __Combine_giveup;
        }

    } else if (precolored.find(u) == precolored.end() &&
               Conservative(getUnion<MIROperand_p>(Adjacent(u), Adjacent(v)))) {
    ///@note Briggs check
    __Combine_try:
        addBySet(coalescedMoves, Moves{m});
        Combine(u, v);
        AddWorkList(u);
    } else {
    __Combine_giveup:
        addBySet(activeMoves, Moves{m});
    }
}

void RegisterAllocImpl::AddWorkList(const MIROperand_p &u) {
    if (precolored.find(u) == precolored.end() && !MoveRelated(u) && degree[u] < K) {
        delBySet(freezeWorkList, WorkList{u});
        addBySet(simplifyWorkList, WorkList{u});
    }
}

void RegisterAllocImpl::Combine(const MIROperand_p &u, const MIROperand_p &v) {
    if (freezeWorkList.find(v) != freezeWorkList.end()) {
        delBySet(freezeWorkList, WorkList{v});
    } else {
        delBySet(spillWorkList, WorkList{v});
    }

    addBySet(coalescedNodes, Nodes{v});
    alias[v] = u;

    ///@note nodeMoves[u] := nodeMoves[u] âˆª nodeMoves[v]
    ///@note æœ‰å……åˆ†çš„ç†ç”±è®¤ä¸ºè®ºæ–‡å†™é”™äº†, å› ä¸ºæ ¹æœ¬æ²¡æœ‰å£°æ˜nodeMoves
    ///@note åº”è¯¥æ˜¯moveList
    addBySet(moveList[u], moveList[v]);

    for (const auto &t : Adjacent(v)) {
        AddEdge(t, u);
        DecrementDegree(t);
    }

    if (degree[u] >= K && freezeWorkList.find(u) != freezeWorkList.end()) {
        delBySet(freezeWorkList, WorkList{u});
        addBySet(spillWorkList, WorkList{u});
    }
}

void RegisterAllocImpl::Freeze() {

    auto it = freezeWorkList.begin();

    auto u = *it;

    delBySet(freezeWorkList, WorkList{u});

    addBySet(simplifyWorkList, WorkList{u});

    FreezeMoves(u);
}

void RegisterAllocImpl::FreezeMoves(const MIROperand_p &u) {
    for (const auto &m : NodeMoves(u)) {
        auto u = *(getUse(m).begin());
        auto v = *(getDef(m).begin());

        if (activeMoves.find(m) != activeMoves.end())
            delBySet(activeMoves, Moves{m});
        else
            delBySet(worklistMoves, Moves{m});

        addBySet(frozenMoves, Moves{m});

        if (NodeMoves(v).empty() && degree[v] < K) {
            delBySet(freezeWorkList, WorkList{v});
            addBySet(simplifyWorkList, WorkList{v});
        }
    }
}

void RegisterAllocImpl::SelectSpill() {
    auto m = heuristicSpill();

    delBySet(spillWorkList, WorkList{m});
    addBySet(simplifyWorkList, WorkList{m});

    FreezeMoves(m);
}
```

##### &emsp;&emsp;&emsp;